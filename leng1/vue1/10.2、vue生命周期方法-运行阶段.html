<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../js/vue.js"></script>
    <style>
        *{margin: 0;padding: 0;}
    </style>
</head>
<body>
    <!-- 这里就是mvvm中的view -->
    <div id="app">
        <p>{{msg}}</p>
    </div>

    <script>
        /**
         * 1、什么是生命周期方法
         *      和wabpack生命周期一样，都是从生到死的特定阶段调用的方法
         *      ps: 生命周期钩子=生命周期函数=生命周期事件
         * 
         * 2、vue生命周期方法分类
         *      2.1、创建期间的生命周期方法
         *          beforeCreate
         *          created
         *          beforeMount
         *          mounted
         *      2.2、运行期间的生命周期方法
         *          beforeUpdate
         *          updated
         *      2.3、销毁期间的生命周期方法
         *          beforeDestroy
         *          destroyed
         * 
        */

        let vue = new Vue({
            beforeUpdate:function(){
                /**
                 * 随时监听data 变化随时准备更新DOM
                 * 在调用 beforeUpdate 的时候，表示vue实例中保存的数据被修改了，但是还没有同步到页面
                 * 注意点：只有保存的数据被修改了才会调用beforeUpdate，否则不会被调用
                 *      
                */
                console.log("beforeUpdate"); 
                console.log(this.msg);//比如数据修改为leng1了，则打印leng1
                console.log(document.querySelector("p").innerHTML);//界面没有更新还是打印 leng
                console.log(document.querySelector("p").innerText);//界面没有更新还是打印 leng

            },
            updated:function(){
                /**
                 * 界面已同步修改
                 * 根据最新的数据重新生成渲染的内容，然后利用杠重新渲染的内容替换之前的内容
                */
                console.log(this.msg);//比如数据修改为leng1了，则打印leng1
                console.log(document.querySelector("p").innerHTML);//界面界面更新为leng1
                console.log(document.querySelector("p").innerText);//界面界面更新为leng1
            },
            el :'#app',
            // 这里就是mvvm中的model
            data:{
                msg:"leng",
            },
            // 专门用于存储监听事件回调函数 
            methods:{
                say(){
                    console.log("say");
                }
            },
            // 专门用于定义计算属性的
            computed:{

            },
            // 专门用于定义局部组件的
            components:{
                
            }
        })
    </script>
</body>
</html>